"""Common benchmark circuits for QuASAr."""
from __future__ import annotations

import math
from functools import lru_cache
from random import Random
from typing import Any, Callable, Dict, Iterable, List, Sequence, Tuple

import numpy as np
from qiskit import QuantumCircuit
from qiskit.synthesis.multi_controlled import synth_mcx_noaux_v24

from quasar.circuit import Circuit, Gate
from quasar.decompositions import decompose_mcx


# Useful constants shared by random tail helpers.
_TWO_PI = 2.0 * math.pi
_PI_OVER_4 = math.pi / 4.0


# Names of gates forming the Clifford group used in benchmark filtering.
CLIFFORD_GATES = {
    "I",
    "X",
    "Y",
    "Z",
    "H",
    "S",
    "SDG",
    "CX",
    "CY",
    "CZ",
    "SWAP",
}

CLIFFORD_PLUS_T_GATES = CLIFFORD_GATES | {"T", "TDG"}


def is_clifford(circuit: Circuit) -> bool:
    """Return ``True`` if ``circuit`` contains only Clifford gates."""

    return all(g.gate in CLIFFORD_GATES for g in circuit.gates)


def is_clifford_plus_t(circuit: Circuit) -> bool:
    """Return ``True`` if ``circuit`` is generated by Clifford+T gates."""

    return all(g.gate in CLIFFORD_PLUS_T_GATES for g in circuit.gates)


def ghz_circuit(n_qubits: int) -> Circuit:
    """Create an ``n_qubits`` GHZ state preparation circuit."""
    gates: List[Gate] = []
    if n_qubits <= 0:
        return Circuit(gates)
    gates.append(Gate("H", [0]))
    for i in range(1, n_qubits):
        gates.append(Gate("CX", [i - 1, i]))
    return Circuit(gates)


def _ghz_spec(n: int) -> List[Gate]:
    """Return a gate list preparing a GHZ state on ``n`` qubits."""

    return list(ghz_circuit(max(0, n)).gates)


def _qft_spec(n: int) -> List[Gate]:
    """Return a list of :class:`Gate` objects for the QFT circuit."""
    gates: List[Gate] = []
    for i in reversed(range(n)):
        gates.append(Gate("H", [i]))
        for j, q in enumerate(reversed(range(0, i))):
            gates.append(Gate("CP", [q, i], {"k": j + 1}))
    return gates


def _iqft_spec(n: int) -> List[Gate]:
    """Return a list of :class:`Gate` objects for the inverse QFT."""
    gates: List[Gate] = []
    for gate in reversed(_qft_spec(n)):
        if gate.gate == "H":
            gates.append(Gate("H", gate.qubits))
        elif gate.gate == "CP":
            k = float(gate.params.get("k", 0))
            phi = -2 * math.pi / (2**k)
            gates.append(Gate("CRZ", gate.qubits, {"phi": phi}))
        else:
            raise ValueError(f"Unsupported gate {gate.gate} in QFT spec")
    return gates


def qft_circuit(n_qubits: int) -> Circuit:
    """Create an ``n_qubits`` quantum Fourier transform circuit."""
    return Circuit(_qft_spec(n_qubits))


def qft_on_ghz_circuit(n_qubits: int) -> Circuit:
    """Apply the QFT to a GHZ state."""
    ghz = ghz_circuit(n_qubits)
    qft = qft_circuit(n_qubits)
    return Circuit(list(ghz.gates) + list(qft.gates))


def _w_state_spec(n: int) -> List[Gate]:

    """Return a gate list for a W state preparation circuit."""
    gates: List[Gate] = []
    if n <= 0:
        return gates
    gates.append(Gate("RY", [0], {"theta": 2 * math.acos(math.sqrt(1 / n))}))

    for q in range(1, n - 1):
        gates.append(
            Gate(
                "CRY",
                [q - 1, q],
                {"theta": 2 * math.acos(math.sqrt(1 / (n - q)))}
            )
        )
    for q in reversed(range(max(0, n - 1))):
        gates.append(Gate("CX", [q, q + 1]))
    gates.append(Gate("X", [0]))
    return gates


def w_state_circuit(n_qubits: int) -> Circuit:
    """Create an ``n_qubits`` W state preparation circuit."""
    gates = _w_state_spec(n_qubits)
    return Circuit(gates)


def grover_circuit(n_qubits: int, n_iterations: int = 1) -> Circuit:
    """Create a Grover search circuit targeting the all-ones state.

    Args:
        n_qubits: Number of search qubits.
        n_iterations: Number of Grover iterations to apply.

    Returns:
        A :class:`Circuit` implementing the algorithm.
    """

    if n_qubits <= 0:
        return Circuit([])

    gates: List[Gate] = []

    # Initial Hadamards
    for q in range(n_qubits):
        gates.append(Gate("H", [q]))

    controls = list(range(n_qubits - 1))
    target = n_qubits - 1

    for _ in range(n_iterations):
        # Oracle marking the all-ones state
        gates.append(Gate("H", [target]))
        gates.extend(_multi_controlled_x(controls, target))
        gates.append(Gate("H", [target]))

        # Diffuser
        for q in range(n_qubits):
            gates.append(Gate("H", [q]))
        for q in range(n_qubits):
            gates.append(Gate("X", [q]))
        gates.append(Gate("H", [target]))
        gates.extend(_multi_controlled_x(controls, target))
        gates.append(Gate("H", [target]))
        for q in range(n_qubits):
            gates.append(Gate("X", [q]))
        for q in range(n_qubits):
            gates.append(Gate("H", [q]))

    return Circuit(gates)


@lru_cache(maxsize=None)
def _mcx_template(num_controls: int) -> List[Gate]:
    """Return a cached ancilla-free MCX template with ``num_controls`` controls."""

    if num_controls < 0:
        raise ValueError("num_controls must be non-negative")

    # Base cases rely on the existing decomposition which is ancilla-free for
    # up to three controls.
    if num_controls <= 3:
        placeholder_controls = list(range(num_controls))
        placeholder_target = num_controls
        gates = decompose_mcx(placeholder_controls, placeholder_target)
        return [
            Gate(gate.gate, list(gate.qubits), dict(gate.params))
            for gate in gates
        ]

    # ``synth_mcx_noaux_v24`` produces an ancilla-free implementation when
    # composed onto a fresh register and decomposed until only elementary
    # single- and two-qubit operations remain.
    num_qubits = num_controls + 1
    circuit = QuantumCircuit(num_qubits)
    circuit.append(synth_mcx_noaux_v24(num_controls).to_gate(), range(num_qubits))

    allowed = {"CX", "P", "RZ", "U", "H"}
    for _ in range(6):
        names = {instruction.operation.name.upper() for instruction in circuit.data}
        if names <= allowed:
            break
        circuit = circuit.decompose()
    else:  # pragma: no cover - defensive, decomposition should converge quickly
        raise RuntimeError("Failed to synthesise ancilla-free MCX decomposition")

    index_map = {qubit: idx for idx, qubit in enumerate(circuit.qubits)}
    template: List[Gate] = []
    for instruction in circuit.data:
        name = instruction.operation.name.upper()
        qubits = [index_map[qubit] for qubit in instruction.qubits]
        params = {
            f"param{idx}": float(value)
            for idx, value in enumerate(instruction.operation.params)
        }
        template.append(Gate(name, qubits, params))
    return template


def _multi_controlled_x(controls: List[int], target: int) -> List[Gate]:
    """Return an ancilla-free decomposition of a multi-controlled X gate."""

    template = _mcx_template(len(controls))
    mapping = {idx: qubit for idx, qubit in enumerate(controls)}
    mapping[len(controls)] = target
    return [
        Gate(gate.gate, [mapping[q] for q in gate.qubits], dict(gate.params))
        for gate in template
    ]


def bernstein_vazirani_circuit(n_qubits: int, secret: int = 0) -> Circuit:
    """Create a Bernstein-Vazirani circuit for a given secret string.

    Args:
        n_qubits: Number of secret bits.
        secret: Integer encoding the secret string (little-endian).

    Returns:
        A :class:`Circuit` implementing the algorithm.
    """

    gates: List[Gate] = []
    if n_qubits <= 0:
        return Circuit(gates)

    anc = n_qubits

    # Initial Hadamards on the search register.
    for q in range(n_qubits):
        gates.append(Gate("H", [q]))

    # Prepare the ancilla in |-> state.
    gates.append(Gate("X", [anc]))
    gates.append(Gate("H", [anc]))

    # Oracle marking the secret string using CNOTs.
    for i in range(n_qubits):
        if (secret >> i) & 1:
            gates.append(Gate("CX", [i, anc]))

    # Final Hadamards to decode the secret string.
    for q in range(n_qubits):
        gates.append(Gate("H", [q]))

    return Circuit(gates)


def amplitude_estimation_circuit(num_qubits: int, probability: float) -> Circuit:
    """Construct an amplitude estimation circuit.

    Args:
        num_qubits: Number of evaluation qubits.
        probability: Success probability encoded by the oracle.

    Returns:
        A :class:`Circuit` implementing a basic amplitude estimation routine.
    """

    if not 0.0 <= probability <= 1.0:
        raise ValueError("probability must lie in [0, 1]")

    theta = 2 * math.asin(math.sqrt(probability))
    gates: List[Gate] = []
    for q in range(num_qubits):
        gates.append(Gate("H", [q]))
    gates.append(Gate("RY", [num_qubits], {"theta": theta}))
    for i in range(num_qubits):
        phi = (2 ** i) * 2 * theta
        gates.append(Gate("CRZ", [i, num_qubits], {"phi": phi}))
    gates.extend(_iqft_spec(num_qubits))
    return Circuit(gates)


def bmw_quark_circuit(num_qubits: int, depth: int, kind: str = "cardinality") -> Circuit:
    """Generate BMW-QUARK ansatz circuits.

    Args:
        num_qubits: Number of qubits.
        depth: Number of alternating rotation/entangling layers.
        kind: ``"cardinality"`` or ``"circular"`` ansatz style.

    Returns:
        The requested ansatz circuit as a :class:`Circuit`.
    """

    gates: List[Gate] = []
    theta = np.pi / 2
    for _ in range(depth):
        for q in range(num_qubits):
            gates.append(Gate("RX", [q], {"theta": theta}))
        if kind == "cardinality":
            for q in range(0, num_qubits - 1, 2):
                gates.append(Gate("RXX", [q, q + 1], {"theta": theta}))
            for q in range(1, num_qubits - 1, 2):
                gates.append(Gate("RXX", [q, q + 1], {"theta": theta}))
        else:  # circular
            for q in range(num_qubits):
                gates.append(Gate("RXX", [q, (q + 1) % num_qubits], {"theta": theta}))
    return Circuit(gates)


def _cdkm_adder_gates(n: int) -> List[Gate]:
    """Gate sequence for the CDKM ripple-carry adder.

    This implements the ``full`` variant of the adder from
    Cuccaro et al. [quant-ph/0410184], acting on two ``n``-qubit
    registers ``a`` and ``b`` with an additional carry qubit at the
    beginning and the end of the layout.  The result is stored in
    ``b`` while ``a`` is restored to its input value.
    """

    if n <= 0:
        return []

    gates: List[Gate] = []
    cin = 0
    a_start = 1
    b_start = 1 + n
    cout = 1 + 2 * n

    def maj(a: int, b: int, c: int) -> None:
        gates.append(Gate("CX", [a, b]))
        gates.append(Gate("CX", [a, c]))
        gates.append(Gate("CCX", [c, b, a]))

    def uma(a: int, b: int, c: int) -> None:
        gates.append(Gate("CCX", [c, b, a]))
        gates.append(Gate("CX", [a, c]))
        gates.append(Gate("CX", [c, b]))

    maj(a_start, b_start, cin)
    for i in range(n - 1):
        maj(a_start + i + 1, b_start + i + 1, a_start + i)

    gates.append(Gate("CX", [a_start + n - 1, cout]))

    for i in reversed(range(n - 1)):
        uma(a_start + i + 1, b_start + i + 1, a_start + i)
    uma(a_start, b_start, cin)

    return gates


def _iqft_gates(n: int, offset: int) -> List[Gate]:
    """Inverse QFT on ``n`` qubits starting at ``offset``."""

    gates: List[Gate] = []
    for j in reversed(range(n)):
        qubit = offset + j
        for k in range(j):
            ctrl = offset + k
            angle = -math.pi / (2 ** (j - k))
            gates.append(Gate("CRZ", [ctrl, qubit], {"theta": angle}))
        gates.append(Gate("H", [qubit]))
    return gates


def _draper_adder_gates(n: int) -> List[Gate]:
    """Gate sequence for the Draper QFT adder (fixed-point variant)."""

    if n <= 0:
        return []

    gates: List[Gate] = []
    a_start = 0
    b_start = n

    # Apply the QFT to the second register using the existing specification
    for gate in _qft_spec(n):
        shifted = Gate(gate.gate, [q + b_start for q in gate.qubits], gate.params)
        gates.append(shifted)

    for j in range(n):
        for k in range(n - j):
            ctrl = a_start + j
            tgt = b_start + j + k
            angle = math.pi / (2 ** k)
            gates.append(Gate("CRZ", [ctrl, tgt], {"theta": angle}))

    # Undo the QFT on the second register
    for gate in _iqft_spec(n):
        shifted = Gate(gate.gate, [q + b_start for q in gate.qubits], gate.params)
        gates.append(shifted)
    return gates


def _vbe_adder_gates(n: int) -> List[Gate]:
    """Gate sequence for the VBE ripple-carry adder."""

    if n <= 0:
        return []

    gates: List[Gate] = []
    cin = 0
    a_start = 1
    b_start = 1 + n
    cout = 1 + 2 * n
    helpers = [cout + 1 + i for i in range(max(0, n - 1))]
    carries = [cin] + helpers + [cout]

    i = 0
    for inp, out in zip(carries[:-1], carries[1:]):
        a_i = a_start + i
        b_i = b_start + i
        gates.append(Gate("CCX", [a_i, b_i, out]))
        gates.append(Gate("CX", [a_i, b_i]))
        gates.append(Gate("CCX", [inp, b_i, out]))
        i += 1

    gates.append(Gate("CX", [a_start + n - 1, b_start + n - 1]))
    if len(carries) > 1:
        inp = carries[-2]
        a_i = a_start + n - 1
        b_i = b_start + n - 1
        gates.append(Gate("CX", [a_i, b_i]))
        gates.append(Gate("CX", [inp, b_i]))

    i -= 2
    for j, (inp, out) in enumerate(
        zip(reversed(carries[:-1]), reversed(carries[1:]))
    ):
        if j == 0:
            continue
        a_i = a_start + i
        b_i = b_start + i
        gates.append(Gate("CCX", [inp, b_i, out]))
        gates.append(Gate("CX", [a_i, b_i]))
        gates.append(Gate("CCX", [a_i, b_i, out]))
        gates.append(Gate("CX", [inp, b_i]))
        gates.append(Gate("CX", [a_i, b_i]))
        i -= 1

    return gates


def adder_circuit(num_qubits: int, kind: str = "cdkm") -> Circuit:
    """Construct CDKM, Draper or VBE adder circuits.

    Args:
        num_qubits: Number of bits in each addend.
        kind: ``"cdkm"``, ``"draper"`` or ``"vbe"``.
    """

    kind = kind.lower()
    if kind == "cdkm":
        gates = _cdkm_adder_gates(num_qubits)
    elif kind == "draper":
        gates = _draper_adder_gates(num_qubits)
    elif kind == "vbe":
        gates = _vbe_adder_gates(num_qubits)
    else:
        raise ValueError("Unknown adder kind")
    return Circuit(gates)


def deutsch_jozsa_circuit(num_qubits: int, balanced: bool = True) -> Circuit:
    """Construct a Deutsch-Jozsa circuit.

    Args:
        num_qubits: Number of input bits.
        balanced: Whether to use a balanced oracle; otherwise constant.
    """

    gates: List[Gate] = []
    if num_qubits < 0:
        raise ValueError("num_qubits must be non-negative")
    # Prepare ancilla in |-> state
    anc = num_qubits
    gates.append(Gate("X", [anc]))
    for q in range(num_qubits + 1):
        gates.append(Gate("H", [q]))
    # Balanced oracle uses CNOTs from each input to ancilla
    if balanced:
        for i in range(num_qubits):
            gates.append(Gate("CX", [i, anc]))
    # Decode the result
    for q in range(num_qubits):
        gates.append(Gate("H", [q]))
    return Circuit(gates)


def graph_state_circuit(num_qubits: int, degree: int, seed: int | None = None) -> Circuit:
    """Generate a random regular graph state circuit."""

    import networkx as nx

    if degree >= num_qubits:
        raise ValueError("degree must be < num_qubits")
    if (num_qubits * degree) % 2 != 0:
        raise ValueError("n * degree must be even for a regular graph")
    g = nx.random_regular_graph(degree, num_qubits, seed=seed)
    gates: List[Gate] = []
    for q in range(num_qubits):
        gates.append(Gate("H", [q]))
    for u, v in g.edges():
        gates.append(Gate("CZ", [u, v]))
    return Circuit(gates)


def hhl_circuit(A: np.ndarray, b: np.ndarray) -> Circuit:
    """Prepare the normalized solution state of ``Ax = b``.

    This implementation classically computes the solution vector and returns a
    circuit that initialises the quantum state ``|x\rangle`` corresponding to
    the normalized result.
    """

    A = np.asarray(A, dtype=complex)
    b = np.asarray(b, dtype=complex)
    if A.shape[0] != A.shape[1]:
        raise ValueError("A must be a square matrix")
    if not np.allclose(A, A.conj().T):
        raise ValueError("A must be Hermitian")
    n = int(math.log2(A.shape[0]))
    if 2**n != A.shape[0] or len(b) != 2**n:
        raise ValueError("Dimension of A and length of b must be 2**n")

    x = np.linalg.solve(A, b)
    x = x / np.linalg.norm(x)
    qc = QuantumCircuit(n)
    qc.initialize(x, range(n))
    return Circuit.from_qiskit(qc)


def hrs_circuit(num_qubits: int) -> Circuit:
    """Construct a toy HRS arithmetic circuit."""

    if num_qubits % 2 != 0:
        raise ValueError("num_qubits must be even for HRS circuit")
    gates: List[Gate] = []
    for i in range(0, num_qubits, 2):
        target = (i + 2) % num_qubits
        gates.append(Gate("CCX", [i, i + 1, target]))
    return Circuit(gates)


def qaoa_circuit(num_qubits: int, repetitions: int = 1, seed: int | None = None) -> Circuit:
    """Create a basic QAOA circuit on a ring graph."""

    rng = np.random.default_rng(seed)
    gammas = rng.uniform(0, 2 * np.pi, size=repetitions)
    betas = rng.uniform(0, 2 * np.pi, size=repetitions)
    edges = [(i, (i + 1) % num_qubits) for i in range(num_qubits)]
    gates: List[Gate] = []
    for q in range(num_qubits):
        gates.append(Gate("H", [q]))
    for p in range(repetitions):
        for u, v in edges:
            gates.append(Gate("RZZ", [u, v], {"theta": float(gammas[p])}))
        for q in range(num_qubits):
            gates.append(Gate("RX", [q], {"theta": float(betas[p])}))
    return Circuit(gates)


def qnn_circuit(num_qubits: int) -> Circuit:
    """Construct a simple quantum neural network circuit."""

    gates: List[Gate] = []
    param = 0
    # ZZFeatureMap: Hadamards followed by pairwise ZZ interactions
    for q in range(num_qubits):
        gates.append(Gate("H", [q]))
    for i in range(num_qubits):
        for j in range(i + 1, num_qubits):
            param += 1
            gates.append(Gate("RZZ", [i, j], {"theta": 0.1 * param}))
    # RealAmplitudes ansatz with a single repetition
    for q in range(num_qubits):
        param += 1
        gates.append(Gate("RY", [q], {"theta": 0.1 * param}))
    for i in range(num_qubits - 1):
        gates.append(Gate("CX", [i, i + 1]))
    for q in range(num_qubits):
        param += 1
        gates.append(Gate("RY", [q], {"theta": 0.1 * param}))
    return Circuit(gates)


def qpe_circuit(num_qubits: int, inexact: bool = False) -> Circuit:
    """Quantum phase estimation circuit.

    Args:
        num_qubits: Number of counting qubits.
        inexact: Whether to use an inexact eigenphase.
    """

    gates: List[Gate] = []
    theta = 2 * math.pi / (2**num_qubits)
    if inexact:
        theta *= 1.1
    for q in range(num_qubits):
        gates.append(Gate("H", [q]))
    for j in range(num_qubits):
        phi = (2**j) * theta
        gates.append(Gate("CRZ", [j, num_qubits], {"phi": phi}))
    gates.extend(_iqft_spec(num_qubits))
    return Circuit(gates)


def quantum_walk_circuit(num_qubits: int, depth: int) -> Circuit:
    """Construct a simple quantum walk circuit."""

    gates: List[Gate] = []
    for q in range(num_qubits):
        gates.append(Gate("H", [q]))
    mcx_name = "C" * (num_qubits - 1) + "X" if num_qubits > 1 else "X"
    for _ in range(depth):
        if num_qubits > 1:
            qubits = list(range(num_qubits))
            gates.append(Gate(mcx_name, qubits))
        for q in range(num_qubits):
            gates.append(Gate("H", [q]))
    return Circuit(gates)


def random_circuit(num_qubits: int, seed: int | None = None) -> Circuit:
    """Generate a random circuit of depth ``2*num_qubits``."""

    rng = np.random.default_rng(seed)
    gates: List[Gate] = []
    depth = 2 * num_qubits
    single_gates = ["H", "RX", "RY"]
    two_gates = ["CX", "CZ", "RZZ"]
    for _ in range(depth):
        for q in range(num_qubits):
            gate = rng.choice(single_gates)
            if gate == "H":
                gates.append(Gate("H", [q]))
            else:
                angle = float(rng.uniform(0, 2 * np.pi))
                gates.append(Gate(gate, [q], {"theta": angle}))
        if num_qubits > 1:
            num_two = int(rng.integers(1, num_qubits))
            used: set[Tuple[int, int]] = set()
            for _ in range(num_two):
                a, b = rng.choice(num_qubits, 2, replace=False)
                if (a, b) in used or (b, a) in used:
                    continue
                used.add((a, b))
                gate = rng.choice(two_gates)
                if gate == "RZZ":
                    angle = float(rng.uniform(0, 2 * np.pi))
                    gates.append(Gate("RZZ", [int(a), int(b)], {"theta": angle}))
                else:
                    gates.append(Gate(gate, [int(a), int(b)]))
    return Circuit(gates)


def shor_circuit(circuit_size: int) -> Circuit:
    """Create a toy Shor factoring circuit of a given size."""

    gates: List[Gate] = []
    for q in range(circuit_size):
        gates.append(Gate("H", [q]))
    if circuit_size > 1:
        gates.append(Gate("CX", [0, circuit_size - 1]))
    gates.extend(_qft_spec(circuit_size))
    return Circuit(gates)


def _entanglement_pairs(
    num_qubits: int, entanglement: str | List[int] | List[List[int]]
) -> List[Tuple[int, int]]:
    """Return pairs of qubits to entangle for ansatz circuits."""

    if isinstance(entanglement, str):
        if entanglement == "full":
            return [(i, j) for i in range(num_qubits) for j in range(i + 1, num_qubits)]
        if entanglement == "linear":
            return [(i, i + 1) for i in range(num_qubits - 1)]
        raise ValueError("Unsupported entanglement pattern")
    pairs: List[Tuple[int, int]] = []
    if not entanglement:
        return pairs
    if isinstance(entanglement[0], (list, tuple)):
        for a, b in entanglement:
            pairs.append((int(a), int(b)))
    else:
        for a, b in zip(entanglement[:-1], entanglement[1:]):
            pairs.append((int(a), int(b)))
    return pairs


def _two_local_gates(
    num_qubits: int,
    reps: int,
    entanglement: str | List[int] | List[List[int]],
    rotation_blocks: List[str],
) -> List[Gate]:
    """Return gates for a generic two-local style ansatz."""

    pairs = _entanglement_pairs(num_qubits, entanglement)
    gates: List[Gate] = []
    param = 0
    # Initial rotation layer
    for q in range(num_qubits):
        for block in rotation_blocks:
            param += 1
            name = "phi" if block == "RZ" else "theta"
            gates.append(Gate(block, [q], {name: 0.1 * param}))
    for _ in range(reps):
        for a, b in pairs:
            gates.append(Gate("CX", [a, b]))
        for q in range(num_qubits):
            for block in rotation_blocks:
                param += 1
                name = "phi" if block == "RZ" else "theta"
                gates.append(Gate(block, [q], {name: 0.1 * param}))
    return gates


def real_amplitudes_circuit(
    num_qubits: int, reps: int = 1, entanglement: str | List[int] | List[List[int]] = "full"
) -> Circuit:
    """Construct a ``RealAmplitudes`` ansatz with bound parameters."""

    gates = _two_local_gates(num_qubits, reps, entanglement, ["RY"])
    return Circuit(gates)


def efficient_su2_circuit(
    num_qubits: int, reps: int = 1, entanglement: str | List[int] | List[List[int]] = "full"
) -> Circuit:
    """Construct an ``EfficientSU2`` ansatz with bound parameters."""

    gates = _two_local_gates(num_qubits, reps, entanglement, ["RY", "RZ"])
    return Circuit(gates)


def two_local_circuit(
    num_qubits: int, reps: int = 1, entanglement: str | List[int] | List[List[int]] = "full"
) -> Circuit:
    """Construct a ``TwoLocal`` ansatz with bound parameters."""

    gates = _two_local_gates(num_qubits, reps, entanglement, ["RY", "RZ"])
    return Circuit(gates)


def clifford_ec_circuit() -> Circuit:
    """Three-qubit bit-flip error-correction circuit using Clifford gates.

    Measurement operations are omitted so the circuit contains only unitary gates.
    """
    gates: List[Gate] = []
    # Encode logical qubit into three data qubits
    gates.append(Gate("H", [0]))
    gates.append(Gate("CX", [0, 1]))
    gates.append(Gate("CX", [0, 2]))
    # Syndrome extraction with two ancilla qubits
    gates.append(Gate("CX", [0, 3]))
    gates.append(Gate("CX", [1, 3]))
    gates.append(Gate("CX", [1, 4]))
    gates.append(Gate("CX", [2, 4]))
    return Circuit(gates)


def ripple_add_circuit(num_bits: int = 4) -> Circuit:
    """Ripple-carry adder for two ``num_bits``-bit registers."""

    return adder_circuit(num_bits, kind="vbe")


def vqe_chain_circuit(num_qubits: int = 6, depth: int = 2) -> Circuit:
    """Parameterized VQE ansatz with linear entanglement chain."""

    gates = _two_local_gates(num_qubits, depth, "linear", ["RY", "RZ"])
    return Circuit(gates)


def random_hybrid_circuit(num_qubits: int = 6, depth: int = 10, seed: int | None = None) -> Circuit:
    """Random circuit mixing Clifford and non-Clifford gates."""
    rng = np.random.default_rng(seed)
    gates: List[Gate] = []
    for _ in range(depth):
        for q in range(num_qubits):
            gate = rng.choice(["H", "S"])
            gates.append(Gate(gate, [q]))
        if num_qubits > 1:
            a, b = rng.choice(num_qubits, 2, replace=False)
            two_gate = "CX" if rng.random() < 0.5 else "CZ"
            gates.append(Gate(two_gate, [int(a), int(b)]))
        gates.append(Gate("T", [int(rng.integers(num_qubits))]))
    return Circuit(gates)


def alternating_ladder_circuit(
    num_qubits: int = 24,
    *,
    dense_gadget_spacing: int = 3,
    gadget_width: int = 4,
    ladder_layers: int = 3,
    gadget_layers: int = 2,
    seed: int = 0,
) -> Circuit:
    """Expose :func:`benchmarks.large_scale_circuits.alternating_ladder_circuit`.

    The helper maps the CLI's ``num_qubits`` parameter to the ladder
    configuration by treating pairs of qubits as ladder rungs.  The
    ``dense_gadget_spacing`` controls how many rungs separate the dense gadget
    regions while ``gadget_layers`` determines how strongly the gadgets drive the
    Schmidt rank across the ladder boundary.  The wrapper raises ``ValueError``
    for odd ``num_qubits`` so that the total qubit count exactly matches the CLI
    input when mapped onto the two rails.
    """

    if num_qubits <= 0:
        return Circuit([])
    if num_qubits % 2 != 0:
        raise ValueError("alternating ladder requires an even number of qubits")

    rung_count = num_qubits // 2
    spacing = max(1, dense_gadget_spacing)
    dense_gadgets = max(1, rung_count // spacing)
    width = min(gadget_width, rung_count)
    ladder_layers = max(1, ladder_layers)
    gadget_layers = max(1, gadget_layers)

    from .large_scale_circuits import alternating_ladder_circuit as _ladder

    circuit = _ladder(
        chain_length=rung_count,
        dense_gadgets=dense_gadgets,
        gadget_width=width,
        ladder_layers=ladder_layers,
        gadget_layers=gadget_layers,
        seed=seed,
    )
    meta = {
        "chain_length": rung_count,
        "dense_gadgets": dense_gadgets,
        "gadget_width": width,
        "ladder_layers": ladder_layers,
        "gadget_layers": gadget_layers,
        "total_qubits": num_qubits,
    }
    setattr(circuit, "metadata", meta)
    return circuit


def surface_corrected_qaoa_circuit(
    bit_width: int, distance: int = 3, rounds: int = 1
) -> Circuit:
    """QAOA on a ring with interleaved surface-code stabiliser cycles.

    This is a thin wrapper around
    :func:`benchmarks.large_scale_circuits.surface_corrected_qaoa` that exposes
    the combined error-correction and algorithmic layers through the CLI.  The
    function accepts a ``bit_width`` for the problem size and inserts a single
    surface-code cycle after each of ``rounds`` QAOA layers on a
    ``distance`` x ``distance`` lattice.

    Parameters
    ----------
    bit_width:
        Number of problem qubits arranged on a cycle graph.
    distance:
        Code distance of the surface-code cycles.  The lattice must contain at
        least ``bit_width`` data qubits.
    rounds:
        Number of QAOA layers, each followed by one surface-code round.

    Returns
    -------
    Circuit
        The assembled circuit interleaving algorithmic and error-correction
        layers.
    """

    from .large_scale_circuits import surface_corrected_qaoa

    return surface_corrected_qaoa(bit_width, distance, rounds)


def recur_subroutine_circuit(num_qubits: int = 4, depth: int = 3) -> Circuit:
    """Circuit invoking a repeated subroutine across layers."""

    gates: List[Gate] = []
    for _ in range(depth):
        for i in range(num_qubits - 1):
            gates.append(Gate("CX", [i, i + 1]))
        for q in range(num_qubits):
            gates.append(Gate("H", [q]))
    return Circuit(gates)


def _remap_gates(gates: Iterable[Gate], qubits: Sequence[int]) -> List[Gate]:
    """Return ``gates`` with local indices remapped to ``qubits``."""

    mapping = list(qubits)
    return [
        Gate(g.gate, [mapping[idx] for idx in g.qubits], dict(g.params))
        for g in gates
    ]


def _random_single_qubit_gate(
    qubit: int, rng: Random, *, include_non_clifford: bool
) -> Gate:
    """Return a random single-qubit gate acting on ``qubit``."""

    if include_non_clifford and rng.random() < 0.4:
        choice = rng.choice(["T", "TDG", "RY", "RZ"])
    else:
        choice = rng.choice(["H", "S", "SDG", "X", "Y", "Z"])
    if choice == "RY":
        return Gate("RY", [qubit], {"theta": rng.uniform(-math.pi, math.pi)})
    if choice == "RZ":
        return Gate("RZ", [qubit], {"phi": rng.uniform(-math.pi, math.pi)})
    return Gate(choice, [qubit])


def _random_two_qubit_gate(
    qubit_a: int, qubit_b: int, rng: Random, *, include_non_clifford: bool
) -> Gate:
    """Return a random two-qubit entangling gate."""

    if include_non_clifford and rng.random() < 0.5:
        control, target = (qubit_a, qubit_b) if rng.random() < 0.5 else (qubit_b, qubit_a)
        phi = rng.uniform(-math.pi, math.pi)
        return Gate("CRZ", [control, target], {"phi": phi})
    name = rng.choice(["CX", "CZ", "SWAP"])
    qubits = [qubit_a, qubit_b]
    if name != "SWAP" and rng.random() < 0.5:
        qubits = [qubit_b, qubit_a]
    return Gate(name, qubits)


def _random_layer(
    num_qubits: int,
    rng: Random,
    *,
    include_non_clifford: bool,
    blocks: Sequence[Sequence[int]] | None = None,
) -> List[Gate]:
    """Return a depth-one layer of random gates confined to ``blocks``."""

    if blocks is None:
        blocks = (tuple(range(num_qubits)),)
    layer: List[Gate] = []
    for block in blocks:
        if not block:
            continue
        for qubit in block:
            layer.append(
                _random_single_qubit_gate(
                    qubit, rng, include_non_clifford=include_non_clifford
                )
            )
        order = list(block)
        rng.shuffle(order)
        for a, b in zip(order[::2], order[1::2]):
            layer.append(
                _random_two_qubit_gate(
                    a, b, rng, include_non_clifford=include_non_clifford
                )
            )
    return layer


def _build_diag_layers(
    num_qubits: int,
    blocks: Sequence[Sequence[int]] | None,
    layers: int,
    rng: Random,
) -> Tuple[List[Gate], List[int], List[bool]]:
    """Return diagonal layers with repeated angles and shared controls."""

    if layers <= 0 or num_qubits <= 0:
        return [], [], []

    if blocks is None:
        block_layout: List[Tuple[int, ...]] = [tuple(range(num_qubits))]
    else:
        block_layout = [tuple(block) for block in blocks if block]
        if not block_layout:
            block_layout = [tuple(range(num_qubits))]

    gates: List[Gate] = []
    offsets: List[int] = []
    non_clifford_layers: List[bool] = []

    for layer in range(layers):
        offsets.append(len(gates))
        phi = (layer % 8 + 1) * (math.pi / 16.0)
        for block in block_layout:
            if len(block) < 2:
                continue
            controls = block[: min(3, len(block))]
            for target in block:
                if target in controls:
                    continue
                gates.append(Gate("CRZ", [controls[0], target], {"phi": phi}))
            if len(controls) >= 2 and len(block) >= 4:
                gates.append(Gate("CCZ", [controls[0], controls[1], block[-1]]))
        non_clifford_layers.append(True)

    return gates, offsets, non_clifford_layers


def _build_layers_from_flags(
    num_qubits: int,
    include_non_clifford: Sequence[bool],
    rng: Random,
    *,
    blocks: Sequence[Sequence[int]] | None = None,
) -> Tuple[List[Gate], List[int], List[bool]]:
    """Return random layers and metadata for the given include flags."""

    gates: List[Gate] = []
    offsets: List[int] = []
    non_clifford_layers: List[bool] = []
    if blocks is None:
        block_layout: Sequence[Sequence[int]] | None = None
        available_qubits = list(range(num_qubits))
    else:
        block_layout = [tuple(block) for block in blocks]
        available_qubits = [q for block in block_layout for q in block]

    for flag in include_non_clifford:
        offsets.append(len(gates))
        layer = _random_layer(
            num_qubits,
            rng,
            include_non_clifford=flag,
            blocks=block_layout,
        )
        if (
            flag
            and all(g.gate in CLIFFORD_GATES for g in layer)
            and available_qubits
        ):
            target = rng.choice(available_qubits)
            layer.append(Gate("T", [target]))
        gates.extend(layer)
        non_clifford_layers.append(
            any(g.gate not in CLIFFORD_GATES for g in layer)
        )
    return gates, offsets, non_clifford_layers


def _resolve_random_depths(depth: int | Sequence[int]) -> List[int]:
    """Normalise depth specifications for random entangling stages."""

    if isinstance(depth, Sequence) and not isinstance(depth, (str, bytes)):
        depths = [int(d) for d in depth]
    else:
        depths = [int(depth)]
    return [max(0, d) for d in depths if d is not None]


def _build_block_local_stage(
    blocks: Sequence[Sequence[int]],
    spec_builder: Callable[[int], Iterable[Gate] | Circuit],
) -> List[Gate]:
    """Return the stage generated by ``spec_builder`` applied within ``blocks``.

    Args:
        blocks: Collections of qubit indices describing the independent
            sub-registers of the clustered circuit.
        spec_builder: Callable that returns an iterable of :class:`Gate`
            objects describing the stage on a local register of the provided
            size. The result may be a :class:`Circuit` or any gate iterable.

    Returns:
        A flat list of gates acting only within the qubits of each block.
    """

    stage_gates: List[Gate] = []
    for block in blocks:
        if not block:
            continue
        local_description = spec_builder(len(block))
        if isinstance(local_description, Circuit):
            local_iterable: Iterable[Gate] = local_description.gates
        else:
            local_iterable = local_description
        stage_gates.extend(_remap_gates(local_iterable, block))
    return stage_gates


def clustered_entanglement_circuit(
    num_qubits: int,
    block_size: int = 5,
    state: str = "ghz",
    entangler: str = "random",
    depth: int | Sequence[int] = 1000,
    *,
    seed: int | None = 1337,
    stage_params: Dict[str, Dict[str, Any]] | None = None,  # optional per-stage kwargs
) -> Circuit:
    """Prepare clustered entangled states followed by configurable workloads.

    The ``stage_params`` mapping customises individual entangler stages by
    name, letting callers bound interaction windows (e.g. for
    ``"banded_qft"`` or ``"neighbor_bridge"``) without altering the public
    entangler string.
    """

    if num_qubits <= 0:
        return Circuit([])
    if block_size <= 0:
        raise ValueError("block_size must be positive")

    rng = Random(seed)
    gates: List[Gate] = []
    blocks: List[List[int]] = []
    for start in range(0, num_qubits, block_size):
        block = list(range(start, min(start + block_size, num_qubits)))
        if not block:
            continue
        blocks.append(block)
        if state.lower() == "ghz":
            prep = _ghz_spec(len(block))
        elif state.lower() == "w":
            prep = _w_state_spec(len(block))
        else:
            raise ValueError(f"unsupported clustered state '{state}'")
        gates.extend(_remap_gates(prep, block))

    prep_gate_count = len(gates)
    entangler_sequence = [
        part.strip().lower()
        for part in entangler.split("+")
        if part.strip()
    ]
    if not entangler_sequence:
        entangler_sequence = ["random"] if depth else []

    random_depths = _resolve_random_depths(depth)
    if not random_depths:
        random_depths = [0]
    random_index = 0
    layer_offsets: List[int] = []
    stage_summaries: List[dict] = []

    params_map = stage_params or {}
    for stage in entangler_sequence:
        stage_start = len(gates)
        summary: dict = {"stage": stage, "start": stage_start}
        sp = params_map.get(stage, {})
        if stage == "random":
            if random_index >= len(random_depths):
                stage_depth = random_depths[-1]
            else:
                stage_depth = random_depths[random_index]
            random_index += 1
            include_flags = [True] * stage_depth
            stage_gates, offsets, non_flags = _build_layers_from_flags(
                num_qubits,
                include_flags,
                rng,
                blocks=blocks,
            )
            layer_offsets.extend(stage_start + offset for offset in offsets)
            summary.update(
                {
                    "depth": stage_depth,
                    "layers": stage_depth,
                    "non_clifford_layers": sum(non_flags),
                }
            )
        elif stage == "diag":
            if random_index >= len(random_depths):
                stage_depth = random_depths[-1] or 2
            else:
                stage_depth = max(1, random_depths[random_index])
            random_index += 1
            stage_gates, offsets, non_flags = _build_diag_layers(
                num_qubits, blocks, stage_depth, rng
            )
            adjusted_offsets = [stage_start + offset for offset in offsets]
            layer_offsets.extend(adjusted_offsets)
            summary.update(
                {
                    "depth": stage_depth,
                    "layers": stage_depth,
                    "non_clifford_layers": sum(non_flags),
                    "offsets": adjusted_offsets,
                }
            )
        elif stage == "xblock_random":
            if random_index >= len(random_depths):
                burst_layers = 2
            else:
                burst_layers = max(1, min(3, random_depths[random_index]))
            random_index += 1
            include_flags = [True] * burst_layers
            stage_gates, offsets, non_flags = _build_layers_from_flags(
                num_qubits,
                include_flags,
                rng,
                blocks=None,
            )
            adjusted_offsets = [stage_start + offset for offset in offsets]
            layer_offsets.extend(adjusted_offsets)
            summary.update(
                {
                    "layers": burst_layers,
                    "non_clifford_layers": sum(non_flags),
                    "offsets": adjusted_offsets,
                }
            )
        elif stage == "global_qft":
            stage_gates = list(_qft_spec(num_qubits))
            summary["layers"] = None
        elif stage == "qft":
            stage_gates = _build_block_local_stage(blocks, _qft_spec)
            summary["layers"] = None
        elif stage == "iqft":
            stage_gates = _build_block_local_stage(blocks, _iqft_spec)
            summary["layers"] = None
        elif stage == "banded_qft":
            region_blocks = max(1, int(sp.get("region_blocks", 3)))
            stage_gates = []
            for idx in range(0, len(blocks), region_blocks):
                region = [q for block in blocks[idx : idx + region_blocks] for q in block]
                if not region:
                    continue
                local_gates = _qft_spec(len(region))
                stage_gates.extend(_remap_gates(local_gates, region))
            summary.update({"layers": None, "region_blocks": region_blocks})
        elif stage == "work_qft":
            work_qubits = max(1, min(num_qubits, int(sp.get("work_qubits", 24))))
            default_start = max(0, num_qubits - work_qubits)
            work_start = int(sp.get("work_start", default_start))
            work_start = max(0, min(num_qubits - work_qubits, work_start))
            work_region = list(range(work_start, work_start + work_qubits))
            local_gates = _qft_spec(len(work_region))
            stage_gates = _remap_gates(local_gates, work_region)
            summary.update(
                {"layers": None, "work_qubits": len(work_region), "work_start": work_start}
            )
        elif stage == "neighbor_bridge":
            bridge_layers = max(1, min(3, int(sp.get("bridge_layers", 2))))
            region_blocks = max(1, int(sp.get("region_blocks", 3)))
            stage_gates = []
            for _ in range(bridge_layers):
                for idx in range(0, len(blocks), region_blocks):
                    region_blocks_slice = blocks[idx : idx + region_blocks]
                    for block_idx in range(len(region_blocks_slice) - 1):
                        qa = region_blocks_slice[block_idx][-1]
                        qb = region_blocks_slice[block_idx + 1][0]
                        stage_gates.append(Gate("CX", [qa, qb]))
            summary.update(
                {
                    "layers": bridge_layers,
                    "region_blocks": region_blocks,
                    "bridge_layers": bridge_layers,
                }
            )
        elif stage == "diag_blocked":
            if random_index >= len(random_depths):
                layers = random_depths[-1] or 2
            else:
                layers = max(1, random_depths[random_index])
            random_index += 1
            stage_gates = []
            for layer in range(layers):
                phi = (layer % 8 + 1) * (math.pi / 16.0)
                for block in blocks:
                    if len(block) < 2:
                        continue
                    ctrls = block[: min(3, len(block))]
                    for target in block:
                        if target in ctrls:
                            continue
                        stage_gates.append(Gate("CRZ", [ctrls[0], target], {"phi": phi}))
                    if len(ctrls) >= 2 and len(block) >= 4:
                        stage_gates.append(Gate("CCZ", [ctrls[0], ctrls[1], block[-1]]))
            summary.update({"layers": layers, "phi_stride": math.pi / 16.0})
        elif stage == "cz_window":
            stage_gates = []
            for block in blocks:
                for control, target in zip(block[::2], block[1::2]):
                    stage_gates.append(Gate("CZ", [control, target]))
            summary.update({"layers": 1})
        elif stage == "grover":
            iterations = max(1, max(1, num_qubits // max(1, block_size)) // 2)
            stage_gates = list(grover_circuit(num_qubits, iterations).gates)
            summary.update({"layers": iterations, "iterations": iterations})
        else:
            raise ValueError(f"unknown entangler stage '{stage}'")

        if stage != "random":
            stage_gates = list(stage_gates)
        gates.extend(stage_gates)
        summary["gate_count"] = len(stage_gates)
        summary["end"] = len(gates)
        stage_summaries.append(summary)

    circuit = Circuit(gates)
    metadata = {
        "family": "clustered_entanglement",
        "state": state.lower(),
        "block_size": block_size,
        "num_blocks": len(blocks),
        "prep_gate_count": prep_gate_count,
        "entangler_sequence": entangler_sequence,
        "random_depths": random_depths,
        "layer_offsets": layer_offsets,
        "stage_summaries": stage_summaries,
        "seed": seed,
    }
    setattr(circuit, "metadata", metadata)
    return circuit


def clustered_ghz_random_circuit(
    num_qubits: int,
    *,
    block_size: int = 5,
    depth: int | Sequence[int] | None = None,
    seed: int | None = 1337,
) -> Circuit:
    """Prepare GHZ clusters followed by random entangling layers.

    Parameters
    ----------
    num_qubits:
        Total number of qubits in the circuit.
    block_size:
        Size of each independent GHZ block. Defaults to ``5`` to match the
        benchmark configuration but can be reduced in tests to keep the gate
        count manageable.
    depth:
        Optional override for the number of random layers applied to each
        block. When omitted the benchmark depth of ``600`` is used.
    seed:
        Random seed forwarded to :func:`clustered_entanglement_circuit`.
    """

    random_depth = 600 if depth is None else depth
    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="ghz",
        entangler="random",
        depth=random_depth,
        seed=seed,
    )


def clustered_ghz_qft_circuit(
    num_qubits: int,
    *,
    block_size: int = 5,
    seed: int | None = 1337,
) -> Circuit:
    """Prepare GHZ clusters followed by a global QFT.

    ``block_size`` and ``seed`` are exposed so tests can shrink the circuit
    while benchmarks retain the original defaults.
    """

    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="ghz",
        entangler="qft",
        depth=0,
        seed=seed,
    )


def clustered_w_random_circuit(
    num_qubits: int,
    *,
    block_size: int = 5,
    depth: int | Sequence[int] | None = None,
    seed: int | None = 1337,
) -> Circuit:
    """Prepare W-state clusters followed by random entangling layers."""

    random_depth = 600 if depth is None else depth
    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="w",
        entangler="random",
        depth=random_depth,
        seed=seed,
    )


def clustered_w_qft_circuit(
    num_qubits: int,
    *,
    block_size: int = 5,
    seed: int | None = 1337,
) -> Circuit:
    """Prepare W-state clusters followed by a QFT."""

    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="w",
        entangler="qft",
        depth=0,
        seed=seed,
    )


def clustered_w_random_xburst_random_circuit(
    num_qubits: int,
    *,
    block_size: int = 8,
    depth: int | Sequence[int] | None = None,
    seed: int | None = 1337,
) -> Circuit:
    """Prepare W clusters with random, cross-block burst and random stages."""

    stage_depths: int | Sequence[int]
    if depth is None:
        stage_depths = (400, 2, 400)
    else:
        stage_depths = depth
    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="w",
        entangler="random+xblock_random+random",
        depth=stage_depths,
        seed=seed,
    )


def clustered_ghz_random_qft_circuit(
    num_qubits: int,
    *,
    block_size: int = 5,
    depth: int | Sequence[int] | None = None,
    seed: int | None = 1337,
) -> Circuit:
    """Prepare GHZ clusters, random layers and a final QFT."""

    random_depth = 600 if depth is None else depth
    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="ghz",
        entangler="random+qft",
        depth=random_depth,
        seed=seed,
    )


def clustered_ghz_random_globalqft_random_circuit(
    num_qubits: int,
    *,
    block_size: int = 8,
    depth: int | Sequence[int] | None = None,
    seed: int | None = 1337,
) -> Circuit:
    """Prepare GHZ clusters with random, global-QFT and random stages."""

    stage_depths: int | Sequence[int]
    if depth is None:
        stage_depths = (600, 0, 600)
    else:
        stage_depths = depth
    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="ghz",
        entangler="random+global_qft+random",
        depth=stage_depths,
        seed=seed,
    )


def clustered_ghz_random_workqft_random_circuit(
    num_qubits: int,
    *,
    block_size: int = 8,
    work_qubits: int = 24,
    work_start: int | None = None,
    depth: int | Sequence[int] = (600, 0, 600),
    seed: int | None = 1337,
) -> Circuit:
    """Random layers stitched with a bounded work-register QFT window."""

    stage_options: Dict[str, Any] = {"work_qubits": work_qubits}
    if work_start is not None:
        stage_options["work_start"] = int(work_start)
    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="ghz",
        entangler="random+work_qft+random",
        depth=depth,
        seed=seed,
        stage_params={"work_qft": stage_options},
    )


def clustered_ghz_diag_globalqft_diag_circuit(
    num_qubits: int,
    *,
    block_size: int = 8,
    depth: int | Sequence[int] | None = None,
    seed: int | None = 1337,
) -> Circuit:
    """Prepare GHZ clusters with diagonal slabs around a global QFT."""

    stage_depths: int | Sequence[int]
    if depth is None:
        stage_depths = (3, 0, 3)
    else:
        stage_depths = depth
    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="ghz",
        entangler="diag+global_qft+diag",
        depth=stage_depths,
        seed=seed,
    )


def clustered_ghz_random_bandedqft_random_circuit(
    num_qubits: int,
    *,
    block_size: int = 8,
    depth: int | Sequence[int] = (600, 0, 600),
    seed: int | None = 1337,
    region_blocks: int = 3,
) -> Circuit:
    """Random layers stitched with a banded QFT landing zone per region."""

    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="ghz",
        entangler="random+banded_qft+random",
        depth=depth,
        seed=seed,
        stage_params={"banded_qft": {"region_blocks": region_blocks}},
    )


def clustered_ghz_diag_bandedqft_diag_circuit(
    num_qubits: int,
    *,
    block_size: int = 8,
    depth: int | Sequence[int] = (3, 0, 3),
    seed: int | None = 1337,
    region_blocks: int = 3,
) -> Circuit:
    """Diagonal slabs stitched with banded QFT regions."""

    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="ghz",
        entangler="diag_blocked+banded_qft+diag_blocked",
        depth=depth,
        seed=seed,
        stage_params={"banded_qft": {"region_blocks": region_blocks}},
    )


def clustered_w_random_neighborbridge_random_circuit(
    num_qubits: int,
    *,
    block_size: int = 8,
    depth: int | Sequence[int] = (400, 2, 400),
    seed: int | None = 1337,
    region_blocks: int = 3,
    bridge_layers: int = 2,
) -> Circuit:
    """W-state clusters with bounded neighbour-bridging stages."""

    return clustered_entanglement_circuit(
        num_qubits,
        block_size=block_size,
        state="w",
        entangler="random+neighbor_bridge+random",
        depth=depth,
        seed=seed,
        stage_params={
            "neighbor_bridge": {
                "region_blocks": region_blocks,
                "bridge_layers": bridge_layers,
            }
        },
    )


def layered_clifford_nonclifford_circuit(
    num_qubits: int,
    depth: int = 2000,
    fraction_clifford: float = 0.8,
    *,
    seed: int | None = 2025,
    islands: int | None = None,
    island_len: int = 2,
    island_gap: int | None = None,
) -> Circuit:
    """Build a layered circuit transitioning from Clifford to non-Clifford gates.

    Providing ``islands``/``island_len``/``island_gap`` rebuilds the post-Clifford
    tail into spaced "magic" windows.  Each window contains ``island_len``
    consecutive non-Clifford layers separated by ``island_gap`` Clifford-only
    layers.  Omitting the trio preserves the original behaviour where every
    post-Clifford layer is non-Clifford.
    """

    if num_qubits <= 0 or depth <= 0:
        return Circuit([])
    if not 0.0 <= fraction_clifford <= 1.0:
        raise ValueError("fraction_clifford must be within [0, 1]")

    rng = Random(seed)
    clifford_layers = min(depth, max(0, int(fraction_clifford * depth)))
    post_clifford_layers = depth - clifford_layers
    include_flags = [False] * clifford_layers

    if islands is not None and post_clifford_layers > 0:
        if islands <= 0:
            raise ValueError("islands must be a positive integer")
        if island_len <= 0:
            raise ValueError("island_len must be a positive integer")
        if island_gap is not None and island_gap < 0:
            raise ValueError("island_gap must be non-negative")
        computed_gap = island_gap
        if computed_gap is None:
            tail = post_clifford_layers
            windows = max(1, islands)
            computed_gap = max(1, tail // windows)

        post_flags: List[bool] = []
        for idx in range(islands):
            if len(post_flags) >= post_clifford_layers:
                break
            remaining = post_clifford_layers - len(post_flags)
            post_flags.extend([True] * min(island_len, remaining))
            if len(post_flags) >= post_clifford_layers:
                break
            if idx < islands - 1 and computed_gap > 0:
                remaining = post_clifford_layers - len(post_flags)
                post_flags.extend([False] * min(computed_gap, remaining))
        if len(post_flags) < post_clifford_layers:
            post_flags.extend([False] * (post_clifford_layers - len(post_flags)))
        if post_flags and not any(post_flags):
            post_flags[-1] = True
        include_flags.extend(post_flags)
    else:
        include_flags.extend([True] * post_clifford_layers)

    gates, offsets, non_flags = _build_layers_from_flags(num_qubits, include_flags, rng)
    circuit = Circuit(gates, use_classical_simplification=False)
    metadata = {
        "family": "layered_clifford_transition",
        "depth": depth,
        "fraction_clifford": fraction_clifford,
        "clifford_layers": clifford_layers,
        "non_clifford_layers": sum(non_flags),
        "transition_layer": clifford_layers,
        "layer_offsets": offsets,
        "non_clifford_layer_flags": non_flags,
        "seed": seed,
    }
    setattr(circuit, "metadata", metadata)
    return circuit


def layered_clifford_midpoint_circuit(num_qubits: int) -> Circuit:
    """Transition to non-Clifford gates halfway through the depth."""

    return layered_clifford_nonclifford_circuit(
        num_qubits, depth=2000, fraction_clifford=0.6
    )


def layered_clifford_delayed_magic_circuit(
    num_qubits: int,
    *,
    depth: int = 2000,
    fraction_clifford: float = 0.8,
    seed: int | None = 2025,
) -> Circuit:
    """Delay the introduction of non-Clifford gates to late layers.

    Parameters mirror :func:`layered_clifford_nonclifford_circuit` so unit tests
    can reduce ``depth`` to keep runtimes low while benchmarks retain the
    original heavy configuration.
    """

    return layered_clifford_nonclifford_circuit(
        num_qubits,
        depth=depth,
        fraction_clifford=fraction_clifford,
        seed=seed,
    )


def layered_clifford_magic_islands_circuit(
    num_qubits: int,
    *,
    depth: int = 2000,
    fraction_clifford: float = 0.9,
    islands: int = 16,
    island_len: int = 2,
    island_gap: int | None = None,
    seed: int | None = 2025,
) -> Circuit:
    """Variant with spaced non-Clifford windows for magic-state "islands"."""

    return layered_clifford_nonclifford_circuit(
        num_qubits,
        depth=depth,
        fraction_clifford=fraction_clifford,
        seed=seed,
        islands=islands,
        island_len=island_len,
        island_gap=island_gap,
    )


def layered_clifford_ramp_circuit(
    num_qubits: int,
    depth: int = 2000,
    ramp_start_fraction: float = 0.5,
    ramp_end_fraction: float = 0.9,
    *,
    seed: int | None = 3030,
) -> Circuit:
    """Gradually increase the non-Clifford density after an initial Clifford prefix."""

    if num_qubits <= 0 or depth <= 0:
        return Circuit([])
    if ramp_start_fraction < 0 or ramp_end_fraction > 1:
        raise ValueError("ramp fractions must lie in [0, 1]")
    if ramp_start_fraction > ramp_end_fraction:
        raise ValueError("ramp_start_fraction must be <= ramp_end_fraction")

    rng = Random(seed)
    start_layer = int(depth * ramp_start_fraction)
    end_layer = int(depth * ramp_end_fraction)
    include_flags: List[bool] = []
    for layer in range(depth):
        if layer < start_layer:
            include_flags.append(False)
        elif layer >= end_layer:
            include_flags.append(True)
        else:
            span = max(1, end_layer - start_layer)
            probability = (layer - start_layer + 1) / span
            include_flags.append(rng.random() < probability)
    if not any(include_flags[start_layer:]):
        include_flags[-1] = True
    gates, offsets, non_flags = _build_layers_from_flags(num_qubits, include_flags, rng)
    circuit = Circuit(gates, use_classical_simplification=False)
    metadata = {
        "family": "layered_clifford_ramp",
        "depth": depth,
        "ramp_start_layer": start_layer,
        "ramp_end_layer": end_layer,
        "layer_offsets": offsets,
        "non_clifford_layer_flags": non_flags,
        "seed": seed,
    }
    setattr(circuit, "metadata", metadata)
    return circuit


def _distance_to_pi_over_4(theta: float) -> float:
    """Return the circular distance from ``theta`` to the closest multiple of π/4."""

    t = theta % _TWO_PI
    min_distance = _TWO_PI
    for k in range(8):
        target = k * _PI_OVER_4
        direct = abs(t - target)
        min_distance = min(min_distance, direct, _TWO_PI - direct)
    return min_distance


def sample_nonclifford_angle(rng: Random, eps: float = 1e-3) -> float:
    """Sample ``θ`` uniformly in ``[0, 2π)`` avoiding Clifford-compatible angles."""

    if eps < 0:
        raise ValueError("eps must be non-negative")
    while True:
        theta = rng.random() * _TWO_PI
        if _distance_to_pi_over_4(theta) > eps:
            return theta


def _normalise_gate_choices(
    choices: Sequence[str | Tuple[str, float]]
) -> Tuple[Tuple[str, float], ...]:
    weighted: list[Tuple[str, float]] = []
    for spec in choices:
        if isinstance(spec, tuple):
            name, weight = spec
        else:
            name, weight = spec, 1.0
        weight = float(weight)
        if weight <= 0:
            continue
        weighted.append((name.upper(), weight))
    if not weighted:
        raise ValueError("At least one gate choice with positive weight is required.")
    return tuple(weighted)


def _weighted_choice(rng: Random, choices: Tuple[Tuple[str, float], ...]) -> str:
    total = sum(weight for _, weight in choices)
    pick = rng.random() * total
    accum = 0.0
    for name, weight in choices:
        accum += weight
        if pick <= accum:
            return name
    return choices[-1][0]


def random_clifford_with_tail_circuit(
    num_qubits: int,
    *,
    clifford_depth: int,
    total_depth: int,
    clifford_seed: int = 1337,
    tail_seed: int = 2025,
    tail_twoq_prob: float = 0.3,
    tail_angle_eps: float = 1e-3,
    tail_oneq_ops: Sequence[str | Tuple[str, float]] = ("RX", "RY", "RZ"),
    tail_twoq_ops: Sequence[str | Tuple[str, float]] = ("CRX", "CRY", "RZX", "RXX", "RYY"),
) -> Circuit:
    """Return a random Clifford circuit with a non-Clifford rotation tail."""

    if num_qubits <= 0:
        return Circuit([], use_classical_simplification=False)
    if clifford_depth < 0:
        raise ValueError("clifford_depth must be non-negative")
    if total_depth <= 0:
        raise ValueError("total_depth must be positive")
    if total_depth < clifford_depth:
        raise ValueError("total_depth must be >= clifford_depth")
    if not (0.0 <= tail_twoq_prob <= 1.0):
        raise ValueError("tail_twoq_prob must lie in [0, 1]")

    tail_layers = total_depth - clifford_depth
    gates: List[Gate] = []

    clifford_rng = Random(
        int(clifford_seed)
        + 1009 * num_qubits
        + 10007 * max(0, clifford_depth)
        + 10037 * total_depth
    )
    for _ in range(clifford_depth):
        for qubit in range(num_qubits):
            roll = clifford_rng.random()
            if roll < 0.33:
                gate = "H"
            elif roll < 0.66:
                gate = "S"
            else:
                gate = "SDG"
            gates.append(Gate(gate, [qubit]))
        if num_qubits > 1:
            for offset in (0, 1):
                for q in range(offset, num_qubits - 1, 2):
                    two_gate = "CX" if clifford_rng.random() < 0.5 else "CZ"
                    gates.append(Gate(two_gate, [q, q + 1]))

    if tail_layers <= 0:
        circuit = Circuit(gates, use_classical_simplification=False)
        metadata = {
            "family": "random_clifford_with_tail",
            "clifford_depth": clifford_depth,
            "total_depth": total_depth,
            "tail_layers": 0,
            "tail_twoq_prob": tail_twoq_prob,
            "tail_angle_eps": tail_angle_eps,
            "clifford_seed": clifford_seed,
            "tail_seed": tail_seed,
        }
        setattr(circuit, "metadata", metadata)
        return circuit

    oneq_choices = _normalise_gate_choices(tail_oneq_ops)
    twoq_choices = _normalise_gate_choices(tail_twoq_ops)
    tail_rng = Random(
        int(tail_seed)
        + 1009 * num_qubits
        + 10007 * max(0, clifford_depth)
        + 10037 * total_depth
    )

    for _ in range(tail_layers):
        for qubit in range(num_qubits):
            gate = _weighted_choice(tail_rng, oneq_choices)
            theta = sample_nonclifford_angle(tail_rng, eps=tail_angle_eps)
            gates.append(Gate(gate, [qubit], {"theta": theta}))
        if num_qubits < 2:
            continue
        for offset in (0, 1):
            for q in range(offset, num_qubits - 1, 2):
                if tail_rng.random() > tail_twoq_prob:
                    continue
                gate = _weighted_choice(tail_rng, twoq_choices)
                theta = sample_nonclifford_angle(tail_rng, eps=tail_angle_eps)
                label = gate.upper()
                if label in {"CRX", "CRY"}:
                    gates.append(Gate(label, [q, q + 1], {"theta": theta}))
                elif label in {"RZX", "RXX", "RYY"}:
                    gates.append(Gate(label, [q, q + 1], {"theta": theta}))
                else:
                    raise ValueError(f"Unsupported tail gate '{gate}'")

    circuit = Circuit(gates, use_classical_simplification=False)
    metadata = {
        "family": "random_clifford_with_tail",
        "clifford_depth": clifford_depth,
        "total_depth": total_depth,
        "tail_layers": tail_layers,
        "tail_twoq_prob": tail_twoq_prob,
        "tail_angle_eps": tail_angle_eps,
        "clifford_seed": clifford_seed,
        "tail_seed": tail_seed,
    }
    setattr(circuit, "metadata", metadata)
    return circuit


def _normalise_classical_qubits(
    classical_qubits: int | Iterable[int], num_qubits: int
) -> List[int]:
    """Normalise ``classical_qubits`` to a sorted list of indices."""

    if isinstance(classical_qubits, Iterable) and not isinstance(
        classical_qubits, (int, float, complex)
    ):
        indices = sorted(
            {
                q
                for q in (int(i) for i in classical_qubits)
                if 0 <= q < num_qubits
            }
        )
    else:
        count = int(classical_qubits)
        if count < 0:
            raise ValueError("number of classical qubits must be non-negative")
        count = min(count, max(0, num_qubits - 1))
        indices = list(range(count))
    return indices


def classical_controlled_circuit(
    num_qubits: int,
    depth: int = 1500,
    classical_qubits: int | Iterable[int] = 8,
    *,
    toggle_period: int = 64,
    fanout: int = 2,
    seed: int | None = 424242,
    diag_fixed_phi: float | None = None,
    diag_period: int | None = None,
    cz_window_period: int | None = None,
) -> Circuit:
    """Large circuit with classical controls triggering simplifications.

    Optional parameters allow stitching diagonal slabs (``diag_fixed_phi`` and
    ``diag_period``) and CZ windows (``cz_window_period``) into the layout.
    """

    if num_qubits <= 1 or depth <= 0:
        return Circuit([])

    classical = _normalise_classical_qubits(classical_qubits, num_qubits)
    if not classical:
        classical = list(range(min(max(1, num_qubits // 4), num_qubits - 1)))
    quantum = [q for q in range(num_qubits) if q not in classical]
    if not quantum:
        raise ValueError("at least one non-classical qubit is required")

    rng = Random(seed)
    gates: List[Gate] = []
    diag_period = None if diag_period is None else max(1, int(diag_period))
    cz_window_period = (
        None if cz_window_period is None else max(1, int(cz_window_period))
    )
    for idx, qubit in enumerate(classical):
        if idx % 2 == 0:
            gates.append(Gate("X", [qubit]))

    prep_gate_count = len(gates)
    layer_offsets: List[int] = []
    toggle_period = max(1, toggle_period)

    for layer in range(depth):
        layer_offsets.append(len(gates))
        if layer > 0 and layer % toggle_period == 0:
            flip_qubit = classical[(layer // toggle_period) % len(classical)]
            gates.append(Gate("X", [flip_qubit]))
        force_cz = bool(
            cz_window_period is not None
            and (layer % (2 * cz_window_period)) < cz_window_period
        )
        diag_active = bool(
            diag_fixed_phi is not None
            and diag_period is not None
            and (layer % (2 * diag_period)) < diag_period
        )
        layer_phi = diag_fixed_phi if diag_active else None
        for target in quantum:
            theta = ((layer + 1) * (target + 1)) % 31 / 31 * math.pi
            phi = (
                layer_phi
                if layer_phi is not None
                else ((layer + 1) * (target + 2)) % 37 / 37 * math.pi
            )
            gates.append(Gate("RY", [target], {"theta": theta}))
            gates.append(Gate("RZ", [target], {"phi": phi}))
        for idx, ctrl in enumerate(classical):
            target = quantum[(layer * fanout + idx) % len(quantum)]
            pattern = (layer + idx) % 3
            if force_cz or diag_active:
                gates.append(Gate("CZ", [ctrl, target]))
            else:
                if pattern == 0:
                    gates.append(Gate("CX", [ctrl, target]))
                elif pattern == 1:
                    gates.append(Gate("CZ", [ctrl, target]))
                else:
                    angle = (
                        layer_phi
                        if layer_phi is not None
                        else ((layer + 1) * (idx + 1)) % 23 / 23 * math.pi
                    )
                    gates.append(Gate("CRZ", [ctrl, target], {"phi": angle}))

    circuit = Circuit(gates, use_classical_simplification=False)
    metadata = {
        "family": "classical_controlled",
        "depth": depth,
        "classical_qubits": classical,
        "quantum_qubits": quantum,
        "prep_gate_count": prep_gate_count,
        "layer_offsets": layer_offsets,
        "toggle_period": toggle_period,
        "fanout": fanout,
        "seed": seed,
    }
    metadata["diag_fixed_phi"] = diag_fixed_phi
    metadata["diag_period"] = diag_period
    metadata["cz_window_period"] = cz_window_period
    setattr(circuit, "metadata", metadata)
    setattr(circuit, "classical_qubits", tuple(classical))
    setattr(circuit, "quantum_qubits", tuple(quantum))
    return circuit


def classical_controlled_dd_sandwich_circuit(num_qubits: int) -> Circuit:
    """Classical-control variant sandwiching a DD-friendly diagonal slab."""

    return classical_controlled_circuit(
        num_qubits,
        depth=1500,
        toggle_period=48,
        fanout=3,
        diag_fixed_phi=math.pi / 4,
        diag_period=16,
        cz_window_period=64,
    )


def dynamic_classical_control_circuit(num_qubits: int) -> Circuit:
    """Classical-control benchmark with frequent basis flips."""

    classical_count = max(4, num_qubits // 3)
    return classical_controlled_circuit(
        num_qubits,
        depth=1500,
        classical_qubits=classical_count,
        toggle_period=32,
        fanout=3,
    )


def classical_controlled_fanout_circuit(num_qubits: int) -> Circuit:
    """Classical-control benchmark with wide fan-out controls."""

    classical_count = max(6, num_qubits // 2)
    return classical_controlled_circuit(
        num_qubits,
        depth=1500,
        classical_qubits=classical_count,
        toggle_period=96,
        fanout=4,
    )
